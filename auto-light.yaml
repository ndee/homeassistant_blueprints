blueprint:
  name: Auto Light (Occupancy + Brightness) with Manual Switch Support
  description: >
    Automatically turns lights on/off based on occupancy and indoor brightness.
    Uses hysteresis (different on/off thresholds) to prevent flickering.
    Configurable off-delay prevents lights from turning off immediately when motion stops.
    Extended with support for connected switches: auto-on after delay when switch turns off the lights (optional), and different auto-off delay when turned on via switch.
    Manual override support via switches and helper for tracking mode.
  domain: automation
  input:
    occupancy_sensor:
      name: Occupancy Sensor
      description: Binary sensor that detects presence/motion (e.g., binary_sensor.detection_area_studio_occupancy_status)
      selector:
        entity:
          domain: binary_sensor

    lights:
      name: Lights
      description: The lights to control (supports entities, devices, areas, or labels)
      selector:
        target:
          entity:
            domain: light

    connected_switches:
      name: Connected Switches (optional)
      description: >
        Entities that reflect manual control of the lights, such as binary sensors detecting physical switch actions or input booleans.
        These should change to 'on' when manually turning lights on, and 'off' when turning off.
        Do not select the light entities themselves, as this may cause loops.
      default: []
      selector:
        entity:
          multiple: true
          domain:
            - binary_sensor
            - switch
            - input_boolean

    manual_mode_helper:
      name: Manual Mode Helper (optional)
      description: Input boolean to track if lights were turned on manually via switches. Create one in Helpers if using switches.
      default: sun.sun
      selector:
        entity:
          domain: input_boolean

    off_timer:
      name: Off Timer (optional)
      description: Timer entity to handle the off delay. Allows cancellation if motion resumes. Create one in Helpers for better reliability.
      default: sun.sun
      selector:
        entity:
          domain: timer

    auto_on_enabled:
      name: Enable Auto ON
      description: Automatically turn lights on when occupancy is detected and brightness is low
      default: true
      selector:
        boolean:

    auto_off_enabled:
      name: Enable Auto OFF
      description: Automatically turn lights off when no occupancy or brightness is high
      default: true
      selector:
        boolean:

    enable_auto_on_after_switch_off:
      name: Enable Auto ON after Switch OFF
      description: Automatically turn lights back on after a delay if switch turns them off but conditions still require them on
      default: true
      selector:
        boolean:

    sleep_mode_entity:
      name: Sleep Mode (optional)
      description: Input boolean for sleep mode - when ON, lights will only turn OFF automatically, never ON
      default: sun.sun
      selector:
        entity:
          domain: input_boolean

    presence_mode_entity:
      name: Presence Mode (optional)
      description: Input boolean for presence - when ON (present), lights can turn on automatically. When OFF (away), lights only turn OFF, never ON
      default: sun.sun
      selector:
        entity:
          domain: input_boolean

    lux_sensor:
      name: Indoor Lux Sensor
      description: Sensor measuring indoor illuminance in lux
      default: sun.sun
      selector:
        entity:
          domain: sensor

    lux_threshold_on:
      name: Turn ON Below (lux)
      description: Turn on lights when brightness is below this value
      default: 50
      selector:
        number:
          min: 0
          max: 1000
          step: 5
          unit_of_measurement: lx
          mode: slider

    lux_threshold_off:
      name: Turn OFF Above (lux)
      description: Turn off lights when brightness exceeds this value (should be higher than ON threshold to prevent flickering)
      default: 100
      selector:
        number:
          min: 0
          max: 1000
          step: 5
          unit_of_measurement: lx
          mode: slider

    off_delay:
      name: Turn OFF Delay (Auto)
      description: Wait this many seconds after conditions for off are met (for auto on mode). Used if no timer provided.
      default: 0
      selector:
        number:
          min: 0
          max: 900
          step: 30
          unit_of_measurement: seconds
          mode: slider

    manual_off_delay:
      name: Turn OFF Delay (Manual)
      description: Wait this many seconds after conditions for off are met when manually turned on via switch
      default: 300
      selector:
        number:
          min: 0
          max: 7200
          step: 30
          unit_of_measurement: seconds
          mode: slider

    auto_on_after_manual_off_delay:
      name: Auto ON Delay after Switch OFF
      description: Delay before automatically turning on after switch turns off the lights
      default: 5
      selector:
        number:
          min: 0
          max: 300
          step: 1
          unit_of_measurement: seconds
          mode: slider

variables:
  auto_on_enabled: !input auto_on_enabled
  auto_off_enabled: !input auto_off_enabled
  enable_auto_on_after_switch_off: !input enable_auto_on_after_switch_off
  sleep_mode_entity: !input sleep_mode_entity
  presence_mode_entity: !input presence_mode_entity
  lux_sensor: !input lux_sensor
  lux_on: !input lux_threshold_on
  lux_off: !input lux_threshold_off
  off_delay: !input off_delay
  manual_mode_helper: !input manual_mode_helper
  has_manual_helper: "{{ manual_mode_helper != 'sun.sun' }}"
  has_switches: "{{ connected_switches | default([]) | length > 0 }}"
  manual_off_delay: !input manual_off_delay
  auto_on_after_manual_off_delay: !input auto_on_after_manual_off_delay
  off_timer: !input off_timer
  has_timer: "{{ off_timer != 'sun.sun' }}"

  # Check if sleep mode is active
  sleep_mode_active: >
    {{ sleep_mode_entity != 'sun.sun' and is_state(sleep_mode_entity, 'on') }}

  # Check if presence mode allows auto-on (not configured OR present)
  presence_allows_on: >
    {{ presence_mode_entity == 'sun.sun' or is_state(presence_mode_entity, 'on') }}

  # Compute whether brightness is low (lights should be on)
  brightness_is_low: >
    {% if lux_sensor != '' and lux_sensor != 'sun.sun' and states(lux_sensor) not in ['unavailable', 'unknown', 'none'] %}
      {{ states(lux_sensor) | float(1000) < lux_on }}
    {% else %}
      false
    {% endif %}

  # Compute whether brightness is high (lights can be turned off)
  brightness_is_high: >
    {% if lux_sensor != '' and lux_sensor != 'sun.sun' and states(lux_sensor) not in ['unavailable', 'unknown', 'none'] %}
      {{ states(lux_sensor) | float(0) > lux_off }}
    {% else %}
      false
    {% endif %}

  manual_active: >
    {{ has_manual_helper and is_state(manual_mode_helper, 'on') }}

  off_delay_var: >
    {{ manual_off_delay if manual_active else off_delay }}

  off_duration_var: >
    {% set s = off_delay_var | int %}
    {{ "{:02d}:{:02d}:{:02d}".format(s // 3600, (s % 3600) // 60, s % 60) }}

trigger:
  # Trigger when occupancy changes
  - platform: state
    entity_id: !input occupancy_sensor
    from: "off"
    to: "on"
    id: motion_detected
  - platform: state
    entity_id: !input occupancy_sensor
    from: "on"
    to: "off"
    id: motion_cleared

  # Trigger when lux sensor changes
  - platform: state
    entity_id: !input lux_sensor
    id: lux_changed

  # Triggers for connected switches (with debounce to ignore rapid flips)
  - platform: state
    entity_id: !input connected_switches
    to: "on"
    for:
      seconds: 1
    id: switch_turned_on
  - platform: state
    entity_id: !input connected_switches
    to: "off"
    for:
      seconds: 1
    id: switch_turned_off

  # Trigger for off timer finished
  - platform: event
    event_type: timer.finished
    event_data:
      entity_id: !input off_timer
    id: off_timer_finished

action:
  - choose:
      # Turn ON: auto-on enabled AND occupancy detected AND brightness is low AND NOT sleeping AND present
      - conditions:
          - condition: template
            value_template: "{{ auto_on_enabled }}"
          - condition: template
            value_template: "{{ not sleep_mode_active }}"
          - condition: template
            value_template: "{{ presence_allows_on }}"
          - condition: state
            entity_id: !input occupancy_sensor
            state: "on"
          - condition: template
            value_template: "{{ brightness_is_low }}"
        sequence:
          - if:
              - condition: template
                value_template: "{{ has_timer and is_state(off_timer, 'active') }}"
            then:
              - service: timer.cancel
                target:
                  entity_id: "{{ off_timer }}"
          - if:
              - condition: template
                value_template: "{{ has_manual_helper }}"
            then:
              - service: input_boolean.turn_off
                target:
                  entity_id: "{{ manual_mode_helper }}"
          - service: light.turn_on
            target: !input lights

      # Start/Handle OFF: auto-off enabled AND (no occupancy OR brightness is high)
      - conditions:
          - condition: template
            value_template: "{{ auto_off_enabled }}"
          - condition: or
            conditions:
              - condition: state
                entity_id: !input occupancy_sensor
                state: "off"
              - condition: template
                value_template: "{{ brightness_is_high }}"
          - condition: trigger
            id:
              - motion_cleared
              - lux_changed
        sequence:
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ has_timer and off_delay_var | int > 0 }}"
                sequence:
                  - service: timer.start
                    data:
                      duration: "{{ off_duration_var }}"
                    target:
                      entity_id: "{{ off_timer }}"
                  - stop: "Started timer for off"
              - conditions:
                  - condition: template
                    value_template: "{{ off_delay_var | int > 0 }}"
                sequence:
                  - delay:
                      seconds: "{{ off_delay_var | int }}"
                  - if:
                      - condition: not
                        conditions:
                          - condition: or
                            conditions:
                              - condition: state
                                entity_id: !input occupancy_sensor
                                state: "off"
                              - condition: template
                                value_template: "{{ brightness_is_high }}"
                    then:
                      - stop: "Off conditions no longer met"
          - if:
              - condition: template
                value_template: "{{ has_manual_helper }}"
            then:
              - service: input_boolean.turn_off
                target:
                  entity_id: "{{ manual_mode_helper }}"
          - service: light.turn_off
            target: !input lights

      # Handle off timer finished: check if still should off, then off
      - conditions:
          - condition: trigger
            id: off_timer_finished
          - condition: template
            value_template: "{{ auto_off_enabled }}"
          - condition: or
            conditions:
              - condition: state
                entity_id: !input occupancy_sensor
                state: "off"
              - condition: template
                value_template: "{{ brightness_is_high }}"
        sequence:
          - if:
              - condition: template
                value_template: "{{ has_manual_helper }}"
            then:
              - service: input_boolean.turn_off
                target:
                  entity_id: "{{ manual_mode_helper }}"
          - service: light.turn_off
            target: !input lights

      # Handle switch turned on: set manual mode if helper exists
      - conditions:
          - condition: trigger
            id: switch_turned_on
          - condition: template
            value_template: "{{ has_switches and has_manual_helper }}"
        sequence:
          - service: input_boolean.turn_on
            target:
              entity_id: "{{ manual_mode_helper }}"

      # Handle switch turned off: reset manual, delay, auto on if enabled and conditions met
      - conditions:
          - condition: trigger
            id: switch_turned_off
          - condition: template
            value_template: "{{ has_switches }}"
        sequence:
          - if:
              - condition: template
                value_template: "{{ has_manual_helper }}"
            then:
              - service: input_boolean.turn_off
                target:
                  entity_id: "{{ manual_mode_helper }}"
          - if:
              - condition: template
                value_template: "{{ enable_auto_on_after_switch_off and auto_on_after_manual_off_delay | int > 0 }}"
            then:
              - delay:
                  seconds: "{{ auto_on_after_manual_off_delay | int }}"
          - if:
              - condition: template
                value_template: "{{ enable_auto_on_after_switch_off and auto_on_enabled and not sleep_mode_active and presence_allows_on and is_state(!input occupancy_sensor, 'on') and brightness_is_low }}"
            then:
              - if:
                  - condition: template
                    value_template: "{{ has_manual_helper }}"
                then:
                  - service: input_boolean.turn_off
                    target:
                      entity_id: "{{ manual_mode_helper }}"
              - service: light.turn_on
                target: !input lights

  # Cancel off timer on motion detected if active
  - if:
      - condition: trigger
        id: motion_detected
      - condition: template
        value_template: "{{ has_timer and is_state(off_timer, 'active') }}"
    then:
      - service: timer.cancel
        target:
          entity_id: "{{ off_timer }}"

mode: restart
max_exceeded: silent

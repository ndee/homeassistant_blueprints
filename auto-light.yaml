blueprint:
  name: Auto Light (Occupancy + Brightness) with Manual Switch Support
  description: >
    Automatically turns lights on/off based on occupancy and indoor brightness.
    Uses hysteresis (different on/off thresholds) to prevent flickering.
    Configurable off-delay prevents lights from turning off immediately when motion stops.
    Extended with support for connected switches: auto-on after delay when switch turns off lights, and different auto-off delay when turned on via switch.
  domain: automation
  input:
    occupancy_sensor:
      name: Occupancy Sensor
      description: Binary sensor that detects presence/motion (e.g., binary_sensor.detection_area_studio_occupancy_status)
      selector:
        entity:
          domain: binary_sensor

    lights:
      name: Lights
      description: The lights to control (supports entities, devices, areas, or labels)
      selector:
        target:
          entity:
            domain: light

    connected_switches:
      name: Connected Switches (optional)
      description: Switches or sensors that manually control the lights. Use entities that change to 'on' for turn on, 'off' for turn off.
      default: []
      selector:
        entity:
          multiple: true

    auto_on_enabled:
      name: Enable Auto ON
      description: Automatically turn lights on when occupancy is detected and brightness is low
      default: true
      selector:
        boolean:

    auto_off_enabled:
      name: Enable Auto OFF
      description: Automatically turn lights off when no occupancy or brightness is high
      default: true
      selector:
        boolean:

    sleep_mode_entity:
      name: Sleep Mode (optional)
      description: Input boolean for sleep mode - when ON, lights will only turn OFF automatically, never ON. When activated, lights turn off after the configured delay.
      default: null
      selector:
        entity:
          domain: input_boolean

    sleep_mode_off_delay:
      name: Sleep Mode Turn OFF Delay (Seconds)
      description: When sleep mode is activated, wait this many seconds before turning off the lights (0 = immediate)
      default: 0
      selector:
        number:
          min: 0
          max: 300
          step: 5
          unit_of_measurement: seconds
          mode: slider

    alarm_panel:
      name: Alarm Panel (optional)
      description: >
        Alarmo alarm control panel for presence mode.
        When disarmed or armed_home/armed_night (someone is home), lights can turn on automatically.
        When armed_away or armed_vacation (away), lights only turn OFF, never ON.
      default: null
      selector:
        entity:
          domain: alarm_control_panel

    lux_sensor:
      name: Indoor Lux Sensor
      description: Sensor measuring indoor illuminance in lux
      default: null
      selector:
        entity:
          domain: sensor

    lux_threshold_on:
      name: Turn ON Below (lux)
      description: Turn on lights when brightness is below this value
      default: 50
      selector:
        number:
          min: 0
          max: 1000
          step: 5
          unit_of_measurement: lx
          mode: slider

    lux_threshold_off:
      name: Turn OFF Above (lux)
      description: Turn off lights when brightness exceeds this value (should be higher than ON threshold to prevent flickering)
      default: 100
      selector:
        number:
          min: 0
          max: 1000
          step: 5
          unit_of_measurement: lx
          mode: slider

    off_delay:
      name: Turn OFF Delay (Auto)
      description: Wait this many seconds after motion stops before turning off lights (0 = immediate) for auto on
      default: 0
      selector:
        number:
          min: 0
          max: 900
          step: 30
          unit_of_measurement: seconds
          mode: slider

    manual_off_delay:
      name: Turn OFF Delay (Manual)
      description: Wait this many seconds after motion stops before turning off lights when manually turned on via switch
      default: 300
      selector:
        number:
          min: 0
          max: 3600
          step: 30
          unit_of_measurement: seconds
          mode: slider

    auto_on_after_manual_off_delay:
      name: Auto ON Delay after Switch OFF
      description: Delay before automatically turning on after switch turns off the lights
      default: 5
      selector:
        number:
          min: 0
          max: 300
          step: 1
          unit_of_measurement: seconds
          mode: slider

    adaptive_lighting_switch:
      name: Adaptive Lighting Switch (optional)
      description: >
        The main enable/disable switch for Adaptive Lighting integration
        (e.g., switch.adaptive_lighting_living_room).
        Will be turned on and applied when lights turn on.
      default: null
      selector:
        entity:
          domain: switch

    adaptive_lighting_sleep_mode_switch:
      name: Adaptive Lighting Sleep Mode Switch (optional)
      description: >
        The sleep mode switch for Adaptive Lighting integration
        (e.g., switch.adaptive_lighting_sleep_mode_living_room).
        Will sync with the sleep_mode_entity state.
      default: null
      selector:
        entity:
          domain: switch

    adaptive_lighting_apply_delay:
      name: Adaptive Lighting Apply Delay (Seconds)
      description: Delay before applying adaptive lighting after lights turn on. Prevents race conditions with slow-responding lights.
      default: 0.5
      selector:
        number:
          min: 0
          max: 5
          step: 0.1
          unit_of_measurement: seconds
          mode: slider

    adaptive_lighting_transition:
      name: Adaptive Lighting Transition Time (Seconds)
      description: Transition time for applying adaptive lighting. 0 = instant change.
      default: 0
      selector:
        number:
          min: 0
          max: 10
          step: 0.5
          unit_of_measurement: seconds
          mode: slider

    adaptive_lighting_prefer_rgb:
      name: Adaptive Lighting Prefer RGB Color
      description: Whether to prefer RGB color adjustment over color temperature when possible.
      default: false
      selector:
        boolean:

    wall_switch_events:
      name: Wall Switch Event Entities (optional)
      description: >
        Event entities for wall switches that support press events
        (e.g., event.hue_wall_switch_module_6_taste_1).
        Triple-toggle detection will work with these.
      default: []
      selector:
        entity:
          domain: event
          multiple: true

    triple_toggle_time_window:
      name: Triple Toggle Time Window (Seconds)
      description: >
        Time window in seconds for detecting triple toggle.
        If the switch is toggled 3 times within this window, adaptive lighting is disabled
        and lights turn on at full brightness with cold white.
      default: 2
      selector:
        number:
          min: 1
          max: 5
          step: 0.5
          unit_of_measurement: seconds
          mode: slider

    state_helper:
      name: State Helper (optional)
      description: >
        An input_text helper to store all automation state as JSON
        (e.g., input_text.auto_light_state).
        Used for: manual mode tracking, triple-toggle detection.
        Required if using connected switches or wall switch events.
      default: null
      selector:
        entity:
          domain: input_text

    full_brightness_color_temp:
      name: Full Brightness Color Temperature (Kelvin)
      description: Color temperature to use when triple-toggle activates full brightness mode.
      default: 6500
      selector:
        number:
          min: 2700
          max: 6500
          step: 100
          unit_of_measurement: K
          mode: slider

variables:
  auto_on_enabled: !input auto_on_enabled
  auto_off_enabled: !input auto_off_enabled
  sleep_mode_entity: !input sleep_mode_entity
  sleep_mode_off_delay: !input sleep_mode_off_delay
  alarm_panel: !input alarm_panel
  lux_sensor: !input lux_sensor
  lux_on: !input lux_threshold_on
  lux_off: !input lux_threshold_off
  off_delay: !input off_delay
  manual_off_delay: !input manual_off_delay
  auto_on_after_manual_off_delay: !input auto_on_after_manual_off_delay
  adaptive_lighting_switch: !input adaptive_lighting_switch
  adaptive_lighting_sleep_mode_switch: !input adaptive_lighting_sleep_mode_switch
  adaptive_lighting_apply_delay: !input adaptive_lighting_apply_delay
  adaptive_lighting_transition: !input adaptive_lighting_transition
  adaptive_lighting_prefer_rgb: !input adaptive_lighting_prefer_rgb
  has_adaptive_lighting: "{{ adaptive_lighting_switch != none and adaptive_lighting_switch != '' }}"
  has_adaptive_lighting_sleep: "{{ adaptive_lighting_sleep_mode_switch != none and adaptive_lighting_sleep_mode_switch != '' }}"
  lights_target: !input lights
  state_helper: !input state_helper
  triple_toggle_time_window: !input triple_toggle_time_window
  full_brightness_color_temp: !input full_brightness_color_temp
  has_state_helper: "{{ state_helper != none and state_helper != '' }}"

  # Parse stored state from JSON helper
  stored_state: >
    {% if has_state_helper %}
      {% set raw = states(state_helper) %}
      {% if raw and raw not in ['unknown', 'unavailable', ''] %}
        {{ raw | from_json }}
      {% else %}
        {{ {'manual_mode': false, 'toggle_count': 0, 'last_toggle': 0} }}
      {% endif %}
    {% else %}
      {{ {'manual_mode': false, 'toggle_count': 0, 'last_toggle': 0} }}
    {% endif %}

  # Check if manual mode is active (from state helper)
  manual_active: >
    {{ has_state_helper and stored_state.get('manual_mode', false) }}

  # Check if sleep mode is active
  sleep_mode_active: >
    {{ sleep_mode_entity != none and sleep_mode_entity != '' and is_state(sleep_mode_entity, 'on') }}

  # Check if presence mode allows auto-on based on alarm panel state
  # Allow auto-on when: not configured, disarmed, armed_home, or armed_night (someone is home)
  # Prevent auto-on when: armed_away or armed_vacation (nobody home)
  presence_allows_on: >
    {{ alarm_panel == none or alarm_panel == '' or states(alarm_panel) in ['disarmed', 'armed_home', 'armed_night'] }}

  # Compute whether brightness is low (lights should be on)
  brightness_is_low: >
    {% if lux_sensor != none and lux_sensor != '' %}
      {{ states(lux_sensor) | float(1000) < lux_on }}
    {% else %}
      false
    {% endif %}

  # Compute whether brightness is high (lights can be turned off)
  brightness_is_high: >
    {% if lux_sensor != none and lux_sensor != '' %}
      {{ states(lux_sensor) | float(0) > lux_off }}
    {% else %}
      false
    {% endif %}

  off_delay_var: >
    {{ manual_off_delay if manual_active else off_delay }}

trigger:
  # Trigger when occupancy changes
  - platform: state
    entity_id: !input occupancy_sensor
    from: "off"
    to: "on"
    id: motion_detected
  - platform: state
    entity_id: !input occupancy_sensor
    from: "on"
    to: "off"
    id: motion_cleared

  # Trigger when lux sensor changes
  - platform: state
    entity_id: !input lux_sensor
    id: lux_changed

  # Triggers for connected switches
  - platform: state
    entity_id: !input connected_switches
    to: "on"
    id: switch_turned_on
  - platform: state
    entity_id: !input connected_switches
    to: "off"
    id: switch_turned_off

  # Trigger when sleep mode is activated
  - platform: state
    entity_id: !input sleep_mode_entity
    from: "off"
    to: "on"
    id: sleep_mode_activated

  # Trigger when sleep mode is deactivated
  - platform: state
    entity_id: !input sleep_mode_entity
    from: "on"
    to: "off"
    id: sleep_mode_deactivated

  # Trigger for wall switch events (for triple-toggle detection)
  - platform: state
    entity_id: !input wall_switch_events
    id: wall_switch_event

action:
  - choose:
      # Turn ON: auto-on enabled AND occupancy detected AND brightness is low AND NOT sleeping AND present
      - conditions:
          - condition: template
            value_template: "{{ auto_on_enabled }}"
          - condition: template
            value_template: "{{ not sleep_mode_active }}"
          - condition: template
            value_template: "{{ presence_allows_on }}"
          - condition: state
            entity_id: !input occupancy_sensor
            state: "on"
          - condition: template
            value_template: "{{ brightness_is_low }}"
        sequence:
          - if:
              - condition: template
                value_template: "{{ has_state_helper and manual_active }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ state_helper }}"
                data:
                  value: >
                    {{ {'manual_mode': false, 'toggle_count': stored_state.get('toggle_count', 0), 'last_toggle': stored_state.get('last_toggle', 0)} | to_json }}
          - service: light.turn_on
            target: !input lights
          - if:
              - condition: template
                value_template: "{{ has_adaptive_lighting }}"
            then:
              - service: switch.turn_on
                target:
                  entity_id: "{{ adaptive_lighting_switch }}"
              - delay:
                  seconds: "{{ adaptive_lighting_apply_delay }}"
              - service: adaptive_lighting.apply
                target:
                  entity_id: "{{ adaptive_lighting_switch }}"
                data:
                  lights: "{{ lights_target.entity_id if lights_target.entity_id is defined else lights_target }}"
                  transition: "{{ adaptive_lighting_transition }}"
                  prefer_rgb_color: "{{ adaptive_lighting_prefer_rgb }}"

      # Turn OFF: auto-off enabled AND (no occupancy OR brightness is high)
      - conditions:
          - condition: template
            value_template: "{{ auto_off_enabled }}"
          - condition: or
            conditions:
              - condition: state
                entity_id: !input occupancy_sensor
                state: "off"
              - condition: template
                value_template: "{{ brightness_is_high }}"
        sequence:
          - if:
              - condition: template
                value_template: "{{ off_delay_var | int > 0 }}"
            then:
              - delay:
                  seconds: "{{ off_delay_var | int }}"
          - if:
              - condition: template
                value_template: "{{ has_state_helper and manual_active }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ state_helper }}"
                data:
                  value: >
                    {{ {'manual_mode': false, 'toggle_count': stored_state.get('toggle_count', 0), 'last_toggle': stored_state.get('last_toggle', 0)} | to_json }}
          - service: light.turn_off
            target: !input lights

      # Handle switch turned on: set manual mode
      - conditions:
          - condition: trigger
            id: switch_turned_on
        sequence:
          - if:
              - condition: template
                value_template: "{{ has_state_helper }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ state_helper }}"
                data:
                  value: >
                    {{ {'manual_mode': true, 'toggle_count': stored_state.get('toggle_count', 0), 'last_toggle': stored_state.get('last_toggle', 0)} | to_json }}

      # Handle switch turned off: reset manual, delay, auto on if conditions
      - conditions:
          - condition: trigger
            id: switch_turned_off
        sequence:
          - if:
              - condition: template
                value_template: "{{ has_state_helper and manual_active }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ state_helper }}"
                data:
                  value: >
                    {{ {'manual_mode': false, 'toggle_count': stored_state.get('toggle_count', 0), 'last_toggle': stored_state.get('last_toggle', 0)} | to_json }}
          - if:
              - condition: template
                value_template: "{{ auto_on_after_manual_off_delay | int > 0 }}"
            then:
              - delay:
                  seconds: "{{ auto_on_after_manual_off_delay | int }}"
          - if:
              - condition: template
                value_template: "{{ auto_on_enabled }}"
              - condition: template
                value_template: "{{ not sleep_mode_active }}"
              - condition: template
                value_template: "{{ presence_allows_on }}"
              - condition: state
                entity_id: !input occupancy_sensor
                state: "on"
              - condition: template
                value_template: "{{ brightness_is_low }}"
            then:
              - service: light.turn_on
                target: !input lights
              - if:
                  - condition: template
                    value_template: "{{ has_adaptive_lighting }}"
                then:
                  - service: switch.turn_on
                    target:
                      entity_id: "{{ adaptive_lighting_switch }}"
                  - delay:
                      seconds: "{{ adaptive_lighting_apply_delay }}"
                  - service: adaptive_lighting.apply
                    target:
                      entity_id: "{{ adaptive_lighting_switch }}"
                    data:
                      lights: "{{ lights_target.entity_id if lights_target.entity_id is defined else lights_target }}"
                      transition: "{{ adaptive_lighting_transition }}"
                      prefer_rgb_color: "{{ adaptive_lighting_prefer_rgb }}"

      # Handle sleep mode activation: turn off lights after delay and sync adaptive lighting sleep mode
      - conditions:
          - condition: trigger
            id: sleep_mode_activated
        sequence:
          - if:
              - condition: template
                value_template: "{{ has_adaptive_lighting_sleep }}"
            then:
              - service: switch.turn_on
                target:
                  entity_id: "{{ adaptive_lighting_sleep_mode_switch }}"
          - if:
              - condition: template
                value_template: "{{ sleep_mode_off_delay | int > 0 }}"
            then:
              - delay:
                  seconds: "{{ sleep_mode_off_delay | int }}"
          - if:
              - condition: template
                value_template: "{{ has_state_helper and manual_active }}"
            then:
              - service: input_text.set_value
                target:
                  entity_id: "{{ state_helper }}"
                data:
                  value: >
                    {{ {'manual_mode': false, 'toggle_count': stored_state.get('toggle_count', 0), 'last_toggle': stored_state.get('last_toggle', 0)} | to_json }}
          - service: light.turn_off
            target: !input lights

      # Handle sleep mode deactivation: sync adaptive lighting sleep mode off
      - conditions:
          - condition: trigger
            id: sleep_mode_deactivated
        sequence:
          - if:
              - condition: template
                value_template: "{{ has_adaptive_lighting_sleep }}"
            then:
              - service: switch.turn_off
                target:
                  entity_id: "{{ adaptive_lighting_sleep_mode_switch }}"

      # Handle wall switch event: triple-toggle detection
      - conditions:
          - condition: trigger
            id: wall_switch_event
          - condition: template
            value_template: "{{ has_state_helper }}"
        sequence:
          - variables:
              current_time: "{{ now().timestamp() }}"
              current_stored: >
                {% set raw = states(state_helper) %}
                {% if raw and raw not in ['unknown', 'unavailable', ''] %}
                  {{ raw | from_json }}
                {% else %}
                  {{ {'manual_mode': false, 'toggle_count': 0, 'last_toggle': 0} }}
                {% endif %}
              last_toggle_time: "{{ current_stored.get('last_toggle', 0) | float(0) }}"
              time_since_last: "{{ current_time - last_toggle_time }}"
              old_count: "{{ current_stored.get('toggle_count', 0) | int(0) }}"
              current_manual: "{{ current_stored.get('manual_mode', false) }}"
              # Reset count if time window expired, otherwise keep it
              base_count: "{{ 0 if time_since_last > triple_toggle_time_window else old_count }}"
              new_count: "{{ base_count + 1 }}"
          # Update state helper with new count and timestamp
          - service: input_text.set_value
            target:
              entity_id: "{{ state_helper }}"
            data:
              value: '{{ {"manual_mode": current_manual, "toggle_count": new_count, "last_toggle": current_time} | to_json }}'
          # Check if we reached 3 toggles
          - if:
              - condition: template
                value_template: "{{ new_count >= 3 }}"
            then:
              # Reset counter in state
              - service: input_text.set_value
                target:
                  entity_id: "{{ state_helper }}"
                data:
                  value: '{{ {"manual_mode": current_manual, "toggle_count": 0, "last_toggle": current_time} | to_json }}'
              # Disable adaptive lighting
              - if:
                  - condition: template
                    value_template: "{{ has_adaptive_lighting }}"
                then:
                  - service: switch.turn_off
                    target:
                      entity_id: "{{ adaptive_lighting_switch }}"
              # Turn on lights at full brightness cold white
              - service: light.turn_on
                target: !input lights
                data:
                  brightness: 255
                  color_temp_kelvin: "{{ full_brightness_color_temp }}"

mode: restart
max_exceeded: silent

blueprint:
  name: Auto Arm/Disarm Alarm (Alarmo)
  description: >
    Automatically arms the alarm when all tracked persons are away for a configurable duration.
    Automatically disarms when one person returns home for a configurable duration.
    Designed for use with the Alarmo integration.
    Robust handling of edge cases and state transitions.
  domain: automation
  input:
    persons:
      name: Persons to Track
      description: Select all persons to track for presence. All must be away to arm, any one home to disarm.
      selector:
        entity:
          domain: person
          multiple: true

    alarm_panel:
      name: Alarm Control Panel
      description: The Alarmo alarm control panel entity
      selector:
        entity:
          domain: alarm_control_panel

    arm_mode:
      name: Arm Mode
      description: Which mode to use when arming the alarm
      default: arm_away
      selector:
        select:
          options:
            - label: Arm Away
              value: arm_away
            - label: Arm Home
              value: arm_home
            - label: Arm Night
              value: arm_night
            - label: Arm Vacation
              value: arm_vacation

    away_delay:
      name: Away Delay (Minutes)
      description: Number of minutes all persons must be away before arming
      default: 5
      selector:
        number:
          min: 0
          max: 60
          step: 1
          unit_of_measurement: minutes
          mode: slider

    home_delay:
      name: Home Delay (Minutes)
      description: Number of minutes a person must be home before disarming
      default: 2
      selector:
        number:
          min: 0
          max: 30
          step: 1
          unit_of_measurement: minutes
          mode: slider

    alarm_code:
      name: Alarm Code (optional)
      description: Code to arm/disarm the alarm (leave empty if not required)
      default: ""
      selector:
        text:
          type: password

    blocking_sensors:
      name: Blocking Sensors (optional)
      description: Sensors that must be off/closed before arming (e.g., doors, windows, motion sensors)
      default: []
      selector:
        entity:
          multiple: true

    error_notification:
      name: Notification on Error (optional)
      description: >
        Action to run when auto arm/disarm fails. Use any notify service (mobile app, Signal, etc.)
        Leave empty to disable. Available variables: {{retry_attempts}}, {{arm_mode}}
      default: []
      selector:
        action: {}

    enable_time_restriction:
      name: Enable Time Restriction
      description: Only auto-arm/disarm during specific times
      default: false
      selector:
        boolean:

    arm_after_time:
      name: Earliest Arm Time
      description: Don't auto-arm before this time (only if time restriction enabled)
      default: "00:00:00"
      selector:
        time:

    arm_before_time:
      name: Latest Arm Time
      description: Don't auto-arm after this time (only if time restriction enabled)
      default: "23:59:59"
      selector:
        time:

    retry_attempts:
      name: Retry Attempts
      description: Number of times to retry if arm/disarm fails
      default: 3
      selector:
        number:
          min: 1
          max: 10
          step: 1

    retry_delay:
      name: Retry Delay (seconds)
      description: Seconds to wait between retry attempts
      default: 5
      selector:
        number:
          min: 1
          max: 60
          step: 1

variables:
  persons: !input persons
  alarm_panel: !input alarm_panel
  alarm_code: !input alarm_code
  arm_mode: !input arm_mode
  blocking_sensors: !input blocking_sensors
  enable_time_restriction: !input enable_time_restriction
  arm_after_time: !input arm_after_time
  arm_before_time: !input arm_before_time
  retry_attempts: !input retry_attempts
  retry_delay: !input retry_delay

  # Check if ALL persons are away (not_home) and NOT in unknown/unavailable states
  all_away: >
    {% set person_list = persons if persons is iterable and persons is not string else [persons] %}
    {% set valid_persons = person_list | reject('match', '^(unknown|unavailable)$') | list %}
    {{ valid_persons | length > 0 and
       valid_persons | map('states') | select('eq', 'not_home') | list | length == valid_persons | length }}

  # Check if at least one person is home (and not in unknown/unavailable state)
  someone_home: >
    {% set person_list = persons if persons is iterable and persons is not string else [persons] %}
    {% set valid_persons = person_list | reject('match', '^(unknown|unavailable)$') | list %}
    {{ valid_persons | map('states') | select('eq', 'home') | list | length > 0 }}

  # Check if all tracked persons are in valid states (not unknown/unavailable)
  all_persons_valid: >
    {% set person_list = persons if persons is iterable and persons is not string else [persons] %}
    {{ person_list | map('states') | reject('match', '^(unknown|unavailable)$') | list | length == person_list | length }}

  # Check if alarm is currently disarmed
  alarm_disarmed: >
    {{ is_state(alarm_panel, 'disarmed') }}

  # Check if alarm is currently armed or in arming/pending state
  alarm_armed_or_arming: >
    {{ states(alarm_panel) in ['armed_away', 'armed_home', 'armed_night', 'armed_vacation', 'arming', 'pending'] }}

  # Check alarm availability
  alarm_available: >
    {{ states(alarm_panel) not in ['unknown', 'unavailable'] }}

  # Check if any blocking sensors are active (prevent arming)
  blocking_sensors_active: >
    {% if blocking_sensors | length > 0 %}
      {% set sensor_list = blocking_sensors if blocking_sensors is iterable and blocking_sensors is not string else [blocking_sensors] %}
      {{ sensor_list | map('states') | select('in', ['on', 'open', 'detected', 'unlocked']) | list | length > 0 }}
    {% else %}
      {{ false }}
    {% endif %}

  # Check if current time is within allowed arming window
  within_time_window: >
    {% if enable_time_restriction %}
      {{ now().strftime('%H:%M:%S') >= arm_after_time and now().strftime('%H:%M:%S') <= arm_before_time }}
    {% else %}
      {{ true }}
    {% endif %}

  # Map arm mode to service name
  arm_service: >
    alarm_control_panel.alarm_{{ arm_mode }}

  # Check if alarm is in triggered state
  alarm_triggered: >
    {{ is_state(alarm_panel, 'triggered') }}

trigger_variables:
  _away_delay: !input away_delay
  _home_delay: !input home_delay

trigger:
  # Any person state changes - we'll filter in conditions
  - platform: state
    entity_id: !input persons
    to: "not_home"
    for:
      minutes: "{{ _away_delay | int }}"
    id: person_away

  - platform: state
    entity_id: !input persons
    to: "home"
    for:
      minutes: "{{ _home_delay | int }}"
    id: person_home

  # Also trigger when alarm state changes to handle edge cases
  - platform: state
    entity_id: !input alarm_panel
    id: alarm_state_changed

condition:
  # Only proceed if alarm is available
  - condition: template
    value_template: "{{ alarm_available }}"

action:
  - choose:
      # ARM: All persons have been away for the configured delay and alarm is disarmed
      - conditions:
          - condition: trigger
            id:
              - person_away
          - condition: template
            value_template: "{{ all_away }}"
          - condition: template
            value_template: "{{ alarm_disarmed }}"
          - condition: template
            value_template: "{{ all_persons_valid }}"
          - condition: template
            value_template: "{{ within_time_window }}"
          - condition: template
            value_template: "{{ not blocking_sensors_active }}"
          - condition: template
            value_template: "{{ not alarm_triggered }}"
        sequence:
          # Double-check all persons are still away before arming
          - condition: template
            value_template: "{{ all_away }}"
          - condition: template
            value_template: "{{ not blocking_sensors_active }}"

          # Attempt to arm with retry logic
          - repeat:
              count: "{{ retry_attempts | int }}"
              sequence:
                - service: "{{ arm_service }}"
                  target:
                    entity_id: !input alarm_panel
                  data:
                    code: "{{ alarm_code if alarm_code != '' else none }}"

                # Wait to verify arming succeeded
                - delay:
                    seconds: 3

                # Check if arming was successful
                - if:
                    - condition: template
                      value_template: "{{ alarm_armed_or_arming }}"
                  then:
                    # Success - exit retry loop (Alarmo handles success notifications)
                    - stop: "Arming successful"
                  else:
                    # Arming failed - wait before retry
                    - if:
                        - condition: template
                          value_template: "{{ repeat.index < retry_attempts }}"
                      then:
                        - delay:
                            seconds: "{{ retry_delay | int }}"

          # If all retries failed, run error notification
          - if:
              - condition: template
                value_template: "{{ not alarm_armed_or_arming }}"
            then:
              - choose:
                  - conditions: []
                    sequence: !input error_notification

      # DISARM: At least one person has been home for the configured delay and alarm is armed/arming
      - conditions:
          - condition: trigger
            id:
              - person_home
          - condition: template
            value_template: "{{ someone_home }}"
          - condition: template
            value_template: "{{ alarm_armed_or_arming }}"
          - condition: template
            value_template: "{{ all_persons_valid }}"
        sequence:
          # Double-check someone is still home before disarming
          - condition: template
            value_template: "{{ someone_home }}"

          # Attempt to disarm with retry logic
          - repeat:
              count: "{{ retry_attempts | int }}"
              sequence:
                - service: alarm_control_panel.alarm_disarm
                  target:
                    entity_id: !input alarm_panel
                  data:
                    code: "{{ alarm_code if alarm_code != '' else none }}"

                # Wait to verify disarming succeeded
                - delay:
                    seconds: 3

                # Check if disarming was successful
                - if:
                    - condition: template
                      value_template: "{{ alarm_disarmed }}"
                  then:
                    # Success - exit retry loop (Alarmo handles success notifications)
                    - stop: "Disarming successful"
                  else:
                    # Disarming failed - wait before retry
                    - if:
                        - condition: template
                          value_template: "{{ repeat.index < retry_attempts }}"
                      then:
                        - delay:
                            seconds: "{{ retry_delay | int }}"

          # If all retries failed, run error notification
          - if:
              - condition: template
                value_template: "{{ not alarm_disarmed }}"
            then:
              - choose:
                  - conditions: []
                    sequence: !input error_notification

      # RECOVERY: If alarm state changed externally and is out of sync, try to correct
      # e.g., if someone is home but alarm is armed, disarm it
      - conditions:
          - condition: trigger
            id: alarm_state_changed
          - condition: template
            value_template: "{{ someone_home and alarm_armed_or_arming }}"
          - condition: template
            value_template: "{{ all_persons_valid }}"
        sequence:
          - delay:
              seconds: 5
          # Re-check conditions after brief delay
          - condition: template
            value_template: "{{ someone_home and alarm_armed_or_arming }}"

          # Attempt to disarm
          - repeat:
              count: "{{ retry_attempts | int }}"
              sequence:
                - service: alarm_control_panel.alarm_disarm
                  target:
                    entity_id: !input alarm_panel
                  data:
                    code: "{{ alarm_code if alarm_code != '' else none }}"

                - delay:
                    seconds: 3

                - if:
                    - condition: template
                      value_template: "{{ alarm_disarmed }}"
                  then:
                    # Success - exit retry loop (Alarmo handles success notifications)
                    - stop: "Recovery successful"
                  else:
                    - if:
                        - condition: template
                          value_template: "{{ repeat.index < retry_attempts }}"
                      then:
                        - delay:
                            seconds: "{{ retry_delay | int }}"

          # Run error notification if recovery failed
          - if:
              - condition: template
                value_template: "{{ not alarm_disarmed }}"
            then:
              - choose:
                  - conditions: []
                    sequence: !input error_notification

mode: parallel
max_exceeded: silent
